#+TITLE: Emacs LISP テクニックバイブル
#+STARTUP: overview
#+TAGS: 必修 知らなかった 気づき わからん
* 必修
** S式編集
- C-M-f: 次のS式へ移動する
- C-M-b: 前のS式へ移動する
- C-M-d: リストの内側へ入る
- C-M-u: リストの外側へ出る
- C-M-SPC: S式をマークする
- C-M-k: S式をカットする
- C-M-t: S式を入れ替える
- M-(: 括弧で囲む
- M-s: 括弧を外す
#+BEGIN_SRC elisp
  (defun a (test)
    (test (foo bar baz) hello) bye
    (foo bar baz))
  (defun hello ()
    (setq a b))
#+END_SRC
** マニュアル
- <f1> m: describe-mode．キーバインドも見れる．
* 逆引き目次
** 数値
** 文字列
** リスト
** オブジェクト
** 制御構造
** 関数
** コマンド
** バッファ
** ファイル
** ミニバッファ
** ウィンドウ
** プロセス
** anything.el
** その他
* Emacs Lisp 始めの一歩
** ようこそ Emacs Lisp の世界へ
*** Emacs Lisp とは
*** Emacs Lisp 習得のメリット・目的
本書のステップ
- elisp の基礎を知る
- バッファとウィンドウによる表現方法を学ぶ
- 関数をすこしずつ覚えていく
- オンラインヘルプの使い方を学ぶ
- 応用的な知識をつける
- Commpn Lisp マクロを使ってエレガントに elisp を書く
- テスト・デバッグの方法を知る
- 実際に elisp で書いてみる
** Emacs Lisp を書くための設定
*** auto-install.el をインストールする
*** 必須ファイルのインストール
- open-junk-file.el
- lispxmp.el
- paredit.el
- auto-async-byte-compile.el
*** 設定
p.31の設定を
[[file:~/Documents/GitHub/dotfiles/.emacs.d/inits/40_EmacsLisp.el::(require%20'lispxmp)%20;;%20Enable%20help%20in%20emacs-lisp-mode][設定ファイル]]に書いたほうがいいかも？
** 文法
*** 括弧だらけの文法
*** 構成要素
*** コメント
** Emacs Lisp プログラム実行の仕組み
*** フォーム
S式の2面性．
- データ
- プログラム（フォーム）
フォームを評価することで，プログラムを実行する
*** 評価とは
フォームを実行して結果を得ること．
*** 関数呼び出し
*** 評価の具体例
#+BEGIN_SRC elisp
  (+ 23 (+ 6 7))                          ; => 36
#+END_SRC
*** クォート
リストやシンボルは，評価されると別物になる．
しかし，これらをデータとしてそのまま関数に渡したい局面がある．
そんなとき，評価を抑制するのがクォート．
#+BEGIN_SRC elisp
  (+ 1 3)                                 ; => 4
  emacs-major-version                     ; => 25

  ;;; クォートの例
  '(+ 1 3)                                ; => (+ 1 3)

  ;;; スペルアウト
  (quote (+ 1 3))                         ; => (+ 1 3)

  ;;; リストやシンボルを関数に渡す例
  ;;(length (+ 1 3))                      ; wrong-type-argument sequencep 4 となって実行できなかった．
  (length '(+ 1 3))                       ; => 3
  (symbol-value 'emacs-major-version)     ; => 25
#+END_SRC
*** 明確性
括弧のおかげで評価の優先順位が明確．
** 評価の方法
*** いろいろな評価の方法
*** 入力補完                                                 :知らなかった:
関数名，変数名を途中まで入力しておき，
M-Tab
で補完．
#+BEGIN_SRC elisp
  ;;; bu-f-na と入力して M-Tab すると
  buffer-file-name                        ;となる．
#+END_SRC
*** コマンド呼び出し
実は，キーを押すごとにも，コマンドが実行されている．
*** ミニバッファにフォームを入力して評価する
M-:
とすると，
M-x eval-expression コマンドが実行されたことになり，ミニバッファに入力したフォームを評価できる．
*** 対話的に評価する
Emacs 終了後に結果が残らないのでおすすめしない．
**** *scratch* バッファ
フォームを入力した後，C-j するとすぐ下に結果が出るらしい．
自分の環境では出なかった．
**** M-x ielm
*** メモファイルにてフォームを評価し，結果を書き込む         :知らなかった:
この方法なら，過去の知的労働の結果を，grep検索するなどして再利用できる．
#+BEGIN_SRC elisp
  (+ 1 3); フォームを書いて，行末で M-; M-; とすると，自動的に矢印が挿入される！！！
  (+ 1 3)                                 ; => 4
  (+ 2 4)                                 ; => 6
  (* 100 3)                               ; => 300
  ;;; C-c C-d とすると，バッファ全体のフォームを評価する！！
  ;;; すごすぎる
#+END_SRC
** 数値
*** 基本的な演算
#+BEGIN_SRC elisp
  ;;; 整数での除算
  (/ 10 3)                                ; => 3

  ;;; 小数での除算
  (/ 10.0 3)                              ; => 3.3333333333333335

  ;;; 剰余
  (% 12 5)                                ; => 2

  ;;; 1だけ足す
  (1+ 3)                                  ; => 4

  ;;; 1だけ引く
  (1- 7)                                  ; => 6

  ;;; (3 + 4) * (10 - 7)
  ;;; 乗算記号の位置に注意！！
  (* (+ 3 4) (- 10 7))                    ; => 21

  ;;; 2 ^ 8
  (expt 2 8)                              ; => 256
#+END_SRC
*** 比較                                                             :注意:
等号の否定が /= なのが間違えそうで危うい
#+BEGIN_SRC elisp
  ;;; 等しい
  (= 10 10)                               ; => t
  (= 10 9)                                ; => nil

  ;;; identical ではなく，equal なのだろう．
  (= 10 10.0)                             ; => t

  ;;; 等しくない
  (/= 10 10)                              ; => nil
  (/= 10 9)                               ; => t

  ;;; 大小比較
  (< 9 10)                                ; => t
  (<= 9 10)                               ; => t
  (> 9 10)                                ; => nil
  (>= 9 10)                               ; => nil

#+END_SRC
*** 整数の範囲
emacs 25 の整数範囲はどうなってるんだろう
#+BEGIN_SRC elisp
  emacs-version                           ; => "25.3.1"

  ;;; 最小値?
  (expt -2 29)                           ; => -536870912

  ;;; 最大値?
  536870911                               ; => 536870911

  ;;; 自分の環境では桁溢れしていない　
  (1- (expt 2 29))                        ; => 536870911
  (expt 2 29)                             ; => 536870912
#+END_SRC
*** 浮動小数点数
#+BEGIN_SRC elisp
  ;;; 科学的記数法
  1e3                                     ; => 1000.0
  1.23e3                                  ; => 1230.0

  ;;; 除算結果を小数で出力
  (/ 10.0 3)                              ; => 3.3333333333333335

  ;;; 整数を浮動小数点数に
  (float 10)                              ; => 10.0

  ;;; 浮動小数点数なら桁溢れせず扱える
  (expt 2 29)                             ; => 536870912
  (expt 2.0 29)                           ; => 536870912.0
  (expt 2.0 54)                           ; => 18014398509481984.0
  (float-time)                            ; => 1545068837.813383

#+END_SRC
** 文字列
*** 文字列の例
#+BEGIN_SRC elisp
  "abc"                                   ; => "abc"

  "
  first
  second"                                 ; => "\nfirst\nsecond"

  ;;; ヒアドキュメントもどき．上の出力と比べよ．
  "\
  first
  second"                                 ; => "first\nsecond"

#+END_SRC
*** バックスラッシュ記法
特殊な文字を表現するために使う．
例えば，\t はタブ記号．

その他は (info "(elisp)CharacterType") を評価せよ．

Meta の評価結果が直感に反する．
#+BEGIN_SRC elisp
  "Ctrl-A = \C-a"                         ; => "Ctrl-A = "
  "Meta-x = \M-x"                         ; => "Meta-x = \370"
  "newline\n"                             ; => "newline\n"
  "double-quote = \""                     ; => "double-quote = \""
  "backslash = \\"                        ; => "backslash = \\"
#+END_SRC

*** 文字
文字そのものの実態は整数．
#+BEGIN_SRC elisp
  ?a                                      ; => 97

  ;;; ヌル文字
  ?\0                                     ; => 0

  ?\C-a                                   ; => 1

  ?あ                                     ; => 12354
  ?\x3042                                 ; => 12354
  "?\x3042"                               ; => "?あ"

#+END_SRC
*** 書式文字列
#+BEGIN_SRC elisp
  (format "%s" "foo")                     ; => "foo"

  ;;; 整数は %s または%d
  (format "%s" 1)                         ; => "1"

  ;;; 右寄せ，左寄せ，0詰め
  (format "[%2d] [%-2d] [%02d]" 3 3 3)    ; => "[ 3] [3 ] [03]"

  ;;; %c は文字を文字列に変換する
  (format "文字から文字列へ: %c" ?a)      ; => "文字から文字列へ: a"

  ;;; %% は % そのものを表す
  (format "%d 円の商品の消費税は，
  税率 %d%% で %d 円です．" 500 8 (* 500 0.08)) ; => "500 円の商品の消費税は，\n税率 8% で 40 円です．"
#+END_SRC

* Emacs Lisp の基礎
** Emacs Lisp プログラムの編集方法
*** S式を操作するコマンド                                            :必修:
- C-M-f: 次のS式へ移動する
- C-M-b: 前のS式へ移動する
- C-M-d: リストの内側へ入る
- C-M-u: リストの外側へ出る
- C-M-SPC: S式をマークする
- C-M-k: S式をカットする
- C-M-t: S式を入れ替える
#+BEGIN_SRC elisp
  (defun test (&optional x)
    (org-clock-in-headline "weekly Review")
    (let ()))
#+END_SRC
*** インデントを整える                                       :知らなかった:
- C-M-a で関数の先頭に移動
- C-M-q でカーソルが指している S式のインデントを整える．
#+BEGIN_SRC elisp

#+END_SRC
*** paredit.el を使用する
- 括弧で囲む: M-(
- 括弧を外す: M-s
ほかにもある．
<f1>m で参照せよ．
** シンボルとオブジェクト
*** シンボル
elispの字句
- 数値
- 文字列
- シンボル: つまり数値でなく，引用符がついていないもの．

コードの大部分がシンボル．
setq や defun もシンボル．
使用可能な文字の種類は多言語の追随を許さない．

*** シンボルと変数・関数                                           :気づき:
- シンボルそのものを評価: 変数名と解釈し，その変数の値が評価結果となる
- リストを評価: 最初の要素を関数と解釈し，その関数を呼び出す．
なるほど，これがリスト言語とよばれる所以か．

**** 同じシンボルに，変数，関数，両方の名前空間を持つことができる
#+BEGIN_SRC elisp
  emacs-version                           ; => "25.3.1"
  (emacs-version)                         ; => "GNU Emacs 25.3.1 (x86_64-apple-darwin13.4.0, NS appkit-1265.21 Version 10.9.5 (Build 13F1911))\n of 2017-09-13"
#+END_SRC

**** ただし，変数と関数が同じ働きをするシンボルもある
#+BEGIN_SRC elisp
  buffer-file-name                        ; => nil
  (buffer-file-name)                      ; => nil
#+END_SRC
*** 代入/ setq
setq スペシャルフォームを使う．
setq は関数ではない．
オブジェクトに，貼ってはがせる名札を貼るイメージ．
#+BEGIN_SRC elisp
  (setq a 1)
  a                                       ; => 1


  (setq a 1.1)
  a                                       ; => 1.1


  (setq a "string"
        b 0)
  a                                       ; => "string"
  b                                       ; => 0


  ;;; 変数 setq に 代入することもできる（もちろん，おすすめしない）
  (setq setq 9999)
  setq                                    ; => 9999
#+END_SRC

*** データ型/ 述語関数で調べよ
オブジェクトには型がある．
オブジェクトのデータ型は述語関数 ~p で調べられる．
pはpredicateの略．
オブジェクトは自身の型を知っており，述語関数によって尋ねられると，答えを返す．

一方，変数には型がない．
（ちょっと，何を言っているのか分からない）
普段は文字列を代入している変数に，関数オブジェクトを代入することできる．

*** 関数名・変数名の命名/ 接頭辞をつけよ
なんと，関数と変数の名前空間は，それぞれ1つしかない．
でも，パッケージごとに接頭辞を付ける決まりがあるので，衝突は起きない．

org.el に登場する関数名・変数名はみなorg-という接頭辞を使っている．

** ローカル変数/ let で代入
オブジェクトを変数に代入する方法はわかった．
でも，変数はどこからでもアクセスできるので，値の追跡が困難．
そこでローカル変数．
*** ローカル変数を定義する/ let と let*
どう違うか
- let: 他のローカル変数の影響を受けない
- let*: 直前の代入の影響を受ける
#+BEGIN_SRC elisp
  (setq x 1)
  x                                       ; => 1

  (let ((x 2)
        null                              ; (null nil) の省略形
        )
    x                                     ; => 2
    null                                  ; => nil
    (let ((x 3))x)
    )

  ;;; let を抜けるとグローバルの値に戻る
  x                                       ; => 1

  ;;; let を使う場合
  (let ((x (+ 5 5))                       ; let の場合，この代入はyには影響しない．
        (y x)                             ; ここではグローバルのxが代入される．
        )
    x                                     ; => 10
    y                                     ; => 1
    (setq x 100)
    x                                     ; => 100
    )


  ;;; let* を使う場合
  (let* ((x (+ 5 5))                      ; let* の場合，この代入はyにも影響する．
         (y x)                            ; ローカルのxが参照される
         )
        x                                 ; => 10
        y                                 ; => 10
        )
#+END_SRC
** コンスセル・リスト・ベクタ
*** コンスセル
S式の「ペア」のこと
#+BEGIN_SRC elisp
  ;;; 一番簡単なコンスセル作成方法　クオートが必要
  '(10 . "ten")                            ; => (10 . "ten")

  ;;; 正式？なコンスセル作成方法
  (cons 10 "ten")                         ; => (10 . "ten")

  ;;; 式を評価しないで残しておきたいときにはドットで区切って書く？
  '((+ 1 2) . 3)                           ; => ((+ 1 2) . 3)
  ;;; cons で作ると評価される
  (cons (+ 1 2) 3)                        ; => (3 . 3)

  ;;; car で左を取得．クオートが必要
  (car '(10 . "ten"))                     ; => 10

  ;;; cdr で右側を取得．クオートが必要
  (cdr '(10 . "ten"))                     ; => "ten"
#+END_SRC
*** リスト
コンスセルのcdrにコンスセルをつなげたもの．
データはcarに入っている．cdrではない．
一番最後のcdrにnilが入っている．
#+BEGIN_SRC elisp

#+END_SRC
*** コンスセルとリストとnil                                      :わからん:
nil は空のリスト．コンスセルではない．
nilがリストとして振る舞えるとべんりなので，(car nil)も(cdr nil)もnilを返すように定義されている．
空のリストという意味合いを強調したいなら，()と書くこともできる．

ただし，nil と (nil) は別物．
- nil の car にはなにもないので ，(car nil) は「無」を表す．
- (nil) は 「nil」 という値．

nil はシンボルであるが，どんな数も設定できない．
nil を評価すると必ず nil になってしまう．
*** ベクタ
**** ベクタがリストより優れている点は？
アクセスの早さ，要素の「変更」の容易さ
配列の一種で，データが横一列に並んでいる．
**** ベクタがリストに劣っている点は？
要素の「追加」ができない点
*** 配列としての文字列
文字列も配列なので，ベクタと同じようにアクセスできる．
書く要素は，文字コードを表す数値．
** 同一性と同値性

** 条件分岐

** ループ
** 正規表現

** 関数定義

** コマンド定義

** コード

** バイトコンパイル

** スタイル
* バッファ・ファイル
* ウィンドウ
* 様々な関数
* Emacs Lisp 応用
* Common Lisp マクロ
* テスト・デバッグ
* Emacs の挙動を変更する
* モード作成
* 外部プログラムとの協調
* 非同期プログラミング
* anything.el で簡単アプリケーション作成
