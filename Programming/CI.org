#+TITLE: 継続的インテグレーション入門
#+STARTUP: overview
* CIの背景--原則とプラクティス
** 始めよう
*** 変更を起点としてビルドを実行する
ビルドとは？
- コンパイル
- テスト
- インスペクション
- デプロイ
CIシステムが図1-1に図解されている．
このシステムの構成要因について，詳しくみていく．
**** 開発者
プライベートビルド（antを使う）に成功してから，変更をコミットする．
**** バージョン管理リポジトリ
OK．
ソフトウェアの構成管理について学ぶには，
「パターンによるソフトウェア構成管理」（スティーブ・P・バーチャックほか）を参照するといい．
**** CIサーバー
変更があるごとにインテグレーションビルドを行う．
**** ビルドスクリプト
CIは人手を介さないのが基本．
**** フィードバック手段
メールなど．
第9章で述べる．
**** インテグレーションビルドマシン
ソフトウェアのインテグレーションのみを行う，独立した1台のマシン．
*** CIの機能
CIが必要とする機能は4つ．
- バージョン管理リポジトリへの接続
- ビルドスクリプト
- フィードバック手段
- ソースコードの変更を統合するプロセス

そして，以下はソースコードの変更を統合するプロセス？
**** ソースコードのコンパイル
**** データベースインテグレーション
**** テスト
**** インスペクション
**** デプロイ
**** ドキュメント生成とフィードバック
*** まとめ
ここまでがCIの概略．
*** 質問
読者のシステムに必要なものを洗い出すための7つの質問
** 継続的インテグレーションの紹介
憶測は失敗の母である--ウェザンの決定保留の法則
思い込みの危険性！
CIは確かに裏方だけど，全ての開発者に，みな自信をもって開発できる平穏を提供する．
ただし，1人の職人に押し付けて終わりというものではない．
*** CIのある1日
メンバーの誰かのコミットによる問題もすぐに検知され，修復することができる．
*** CIの価値とは？
**** リスク軽減
毎日何度もインテグレーション
- 欠陥の検出と修正を迅速に
- ソフトの健康状態を計測できる
- 思い込みを減らす

**** 繰り返し手作業軽減
- 常に同じ方法でプロセス実行
- 指定した順序でプロセス実行
- コミットのたびに実行
**** いつでもデプロイ
いつでもリリースできるようになる
資源評価でいえば，いつ提出しても間違いがない状態．
最後に大きいチェックをして，間違い発覚，ということがない．
**** プロジェクトの見える化
- 効果的な判断
- 様々な傾向の発見

**** チームの自信向上

*** CIの導入を妨げるものは何か？
懸念があって導入をためらうようだ．
**** 維持が大変なのでは？
CIシステムの管理の方が，手作業のプロセスにコントロールされるより楽．
**** これまでのやり方が大きく変わってしまうのでは？
低い頻度から初め，満足度が高まってきたら頻繁にするといい．
**** ビルドエラーがたくさん出るのでは？
それはプライベートビルドをせずにコミットしているから．
**** ハードウェア/ソフトウェアの費用が高いのでは？
ビルドマシンを買う必要があるが，開発終盤で問題が発見されたときのコストに比べれば安いもの．
**** 開発者の作業と同じでは？
専用の環境を使うことで，人間よりも効率よく，確実に，頻繁にやることができる．
初期化されたクリーンな環境動く自信がつく．
*** 「継続的」なインテグレーションに必要なものは？
*I* *B* uild *S* o *C* onsistently.
- Identify(特定): 自動化すべきプロセスを特定する．たとえばコンパイル，テスト，インスペクション，デプロイ，データベースインテグレーション．
- Build(ビルド): ビルドスクリプトを作成する．.NETならNAnt, JavaならAnt, RubyならRake．他の言語は？
- Share(共有): バージョン管理システム
- (Continuous): 継続化: CIサーバで自動化プロセスを実行

CIシステムは少しずつ成長させよう．
次は何が必要かを考える．
プロジェクトのリスクに基づき，必要に応じて自動化プロセスを追加する．
**** 継続的「インテグレーション」だと思っているそれはただの継続的「コンパイル」ではないか？
次の質問に答えられるか？
- テストでのコード網羅率
- ビルドの実行時間
- コードの複雑度の平均値
- コードの重複の度合
- パージョン管理リポジトリのビルドへラベル付けをしているか
- デプロイしたソフトウェアはどこに格納されているか
*** CI導入の時期と方法は？
CI導入に最適なのは，プロジェクトの初期．
ソースコードのコンパイルやバイナリのパッケージ化から始めるのが良い．
自動テストはやらないでおく．
開発者たちがCIに馴染んできたら，テストも自動化する．

*** インテグレーションの進化
CIは最新で再考のアプローチか？
否．手法進化の一歩でしかない．
プログラムが小規模だったときは，日次ビルド，夜間ビルドで十分だった．

*** CIと他のプラクティスの関係は？

**** 開発者テスト
開発者が普段使っているテスト環境は，自動化できるだろう．
自動化すれば，CIの一部に組み込める．
**** コーディング標準の遵守
人間がレビューする前に，静的解析ツールで自動レビューをせよ
**** リファクタリング
CインスペクションツールをCIに組み込み，潜在的な問題箇所を特定．
**** 小規模リリース
実質的にリリース版はいつでも利用可能．
最高に相性がいい．
**** 共同所有
システムの特定の領域についての知識が1人の個人に集中してしまう「知識の縦割り」を防ぐことができる．

*** CI環境のセットアップにどれぐらい時間がかかるのか？
若いプロジェクトなら2〜3時間．
成熟してしまったプロジェクトだと数日〜数ヶ月．

*** CIと開発者
開発者はこれまでの習慣を変えないといけない．
以下で，遵守すべき7つのプラクティスを詳しく見ていく．

*** プラクティス1: 頻繁にコードをコミットする
- 変更内容を小さくする
- タスク完了時にコミットする
帰る間際にまとめてコミットしないように
*** プラクティス2: ビルドが失敗したコードをコミットしない
コミット前に，インテグレーションのビルドプロセスと同じやり方でプライベートビルドを行う．

*** プラクティス3: 失敗したビルドをすみやかに修復する
エラーは少しずつ発見されていくので，対処も小さくて済む．
*** プラクティス4: 開発者テストを自動化する
テストも自動化が不可欠．第6章で述べる．
*** プラクティス5: すべてのテストとインスペクションを合格させる
網羅率計測ツールを使うことで，対応するテストケースがないソースコードを特定できる．
このツールもCIに組みこむことができる．
*** プラクティス6: プライベートビルドを実行する
他の開発者の変更も取り込み，自分の変更と合わせてビルドする
*** プラクティス7: ビルドが失敗したコードを取得しない
光や音でフィードバックがあるといい．
ビルド失敗に関係している開発者は，すぐにコード修正とバージョン管理リポジトリへの再コミット作業にとりかかるべき．
*** まとめ
読者がCIについて話し合う材料がそろった．
- CIの基本原則の一部を説明した
- 継続的なプロセスにたどり着くための方法を述べた
- 以降の章で検討する領域について言及した
- CIの7つのプラクティスをp.66 の表2-1にまとめた
*** 質問
- チーム全員が，少なくとも平均して1日に1回，コードをコミットしているか．頻繁にコードをコミットするのが楽になるような工夫をしているか
- 毎日のインテグレーションの成功率は何%か．直近のビルドが正常終了したかどうかを知っているか
- インテグレーションのエラーを減らすために，チーム全員がプライベートビルドを完了してからコミットしているか
- テストやインスペクションに1つでも失敗したら，ビルドが失敗するようになっているか
- 失敗したインテグレーションビルドの修復が最優先されているか
- ビルドが失敗しているとき，パージョン管理リポジトリから最新のコードを取得しないようにしているか
- ビルドやCIシステムに自動化されたプロセスを追加することを，どれくらいの頻度で検討しているか．継続的に，または定期的に検討しているか
** CIによるリスクの軽減
高い品質とは，だれも見ていないときでも，きちんとやることだ．--ヘンリー・フォード
CI導入によって避けられるようになるリスクを紹介する
- 欠陥検出の遅れ
- プロジェクトの「見える化」不足
- 低品質なソフトウェア
- デプロイできないソフトウェア
スケジュールが迫ると，いろんなチェックがおろそかになる．
リスクに「気づく」ことはできても，そのリスクを軽減できているとは限らない．
*** リスク: デプロイできないソフトウェア
ビルド成功が納期ギリギリになる地獄

なぜこうなるか？
ビルドを自動化していなかったため，ビルドのオーバーヘッドが毎回大きく，だんだん面倒になっていった．
毎回初期化される専用環境上でビルドしていなかったため，ソフトウェアが正しくビルドされていると確信できなかった．

**** シナリオ: 自分のマシンでは動いている
CruiseControlなどのCIサーバを使い，バージョン管理リポジトリの変更を監視すべき．
変更があったら，ただちにビルドスクリプトが実行される．
**** シナリオ: データベースとの同期
データベースと開発チームが別れていることがある．
2つのチームが統合されていないのに，チーム間の共同作業が成功するはずがない
- データベースに関する成果物は，全てバージョン管理リポジトリで管理する
- ビルドスクリプトでデータベースやデータを再構築する
- データベースのテストを行う
**** シナリオ: クリックし忘れ
Antのビルドスクリプトを使ってデプロイ作業を自動化すべき
CruiseControlが変更を検知したとき，いつもこのスクリプトが実行される．
*** リスク: 欠陥検出の遅れ
**** シナリオ: 回帰テスト
ビルドスクリプトからテストを実行する
**** シナリオ: テスト網羅率
コード網羅率計測ツールを使う．
*** リスク: プロジェクトの「見える化」不足
**** シナリオ: メモを受け取った？
メールを受信できないときにはショートメッセージなど．
**** シナリオ: ソフトウェアを「見える化」できない
CIシステムにDoxygenという自動コード文書化ツールを導入すべき．
Doxygen: ソースコードを文書化し，UML図も生成する．
*** リスク: 低品質なソフトウェア
**** シナリオ: コーディング標準の遵守
解決事例
- コーディング標準の全てを含む1ページ文の注釈をつけたクラスを作った
- 自動化されたインスペクションツールを使い，コーディング標準に準拠していないコードの行を全てHTML形式で報告するようにした
**** シナリオ: アーキテクチャの遵守
UMLモデリングツールが吐き出したコードでコーディングを始めても，徐々にずれていってしまう．
アーキテクチャも変更されたりする．

自動化されたインスペクションツールを使う．
JDepend や NDependなどの依存関係解析ツールを使っても良い．
**** シナリオ: 複製されたコード
コピペされたコードは，バグを撒き散らす可能性もある．
以下のようなツールを使うと，インスペクションを自動化できる
自動化によって検出される度に，リファクタリングするべき．
- PMDのCPD
- Simianの静的解析ツール
もちろん，CIシステムに組み込んで継続的にコード重複の検査をせよ
*** まとめ
*** 質問
- プロジェクトで欠陥が最も多く検出されるのは，ライフサイクルの前半と後半，どちらか？
- プロジェクトではどのように品質を測定しているか？また，品質を測定できているか？
- プロジェクトでは，どのプロセスを手動でやっている？自動化できるプロセスはある？
- データベースやデータを再作成するためのスクリプト全てをバージョン管理リポジトリに格納しているか？
- ソフトウェアに変更があった時には，いつでも回帰テストをできるか？
- 対応するテストが存在しないソースコードを見つけることができるか？網羅率計測ツールを使っているか？
- ソフトウェア中に超速コードが何%存在するか？
- 最新のソースコードが，ソフトウェアのアーキテクチャに従っていることをどのように検証しているか？
- ビルドやデプロイが完了しており，いつでもテスト可能であることを，どうやって周知しているか？プロジェクトの情報伝達のうち，自動化できるものはあるか？
- ソフトウェアの現状を表すビジュアルな図表はあるか？
** 変更を起点としたビルドの実行
すべてを1度バラバラに分解する．そして1から組み立て直すのだ．--ヘンリー・ミラー
日次ビルドをしないチームなど，T型フォードを手作業で組み立てている水準と同じといっていい．
* CIシステムの構築
** 継続的データベースインテグレーション
略してCDBI．
データベースインテグレーションもCIの重要なパーツの一つ．
データベースコードも本質的にはシステムを構成する他のコードと変わらない．
** 継続的テスト
習うより慣れろ．
線形システムの信頼性は，各構成要素の信頼性の積である．和ではない．
信頼性90%の構成要素3つからなるシステムの信頼説は73%．
** 継続的インスペクション
感情を持った人間がコードレビューをすることには，デメリットもある．
感情と客観性の問題．

- 機械によるレビュー
- 人によるレビュー
これらは，どちらか1つに絞るべきものではない．むしろ，相補的に使うべき．
まず機械がやって，次に人間．
** 継続的デプロイ
何かをうまくこなしたいのなら，自分でやることだ．
「リリースの悪夢」
徹夜したのに，納品できない．
利用可能な状態のソフトウェアをいつでも，どこで，そして最小限の労力でリリースし続けること．
** 継続的フィードバック
人生において最も成功するのは，最良の情報を持つ者である．--ベンジャミン・ディズレーリ
失敗したときにすぐに通知が来る．
適切な情報を，適切な人に適切なタイミングで提供することが重要．
具体的にどうすればいいかを解説する．
* 付録
