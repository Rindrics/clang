#+TITLE: Rパッケージ開発入門
#+STARTUP: overview
* 第一歩
** はじめに
なぜ本書で学ぶスキルが重要か

本書のゴール: 自力でバッケージを書けるようになること
なぜパッケージを書くのか
- 人と共有したいコードがある
- 規約に従うことによって自分自身の時間を節約するため
*** 哲学
自動化できるものは自動化する！これはdevtoolsでできる．
**** devtools のデメリット
パッケージがどのように構成されているのかを遮蔽してしまう．
詳しく学ぶには公式の[[http://bit.ly/iEYWyMy][Writing R Extensions]]が一番．
ただし，難しいので基本を理解してから．
*** 学習開始
**** パッケージのインストール
#+BEGIN_SRC R
  install.packages(c("devtools", "roxygen2", "testthat", "knitr"))
  devtools::install_github("hadley/devtools")
#+END_SRC
**** その他必要なもの
Xcode または Command-Line Tools for Xcode
** パッケージの構造
- パッケージの基本的な構造
- どのような形式をとれるのか
*** パッケージに名前をつける
**** 名前の要件
- 文字と数字（とピリオド: 非推奨）だけで構成されること
- 文字で始まること
- ピリオドでは終わらないこと
**** 名前を付ける方法
- Google で検索しやすく
- 大文字と小文字の両方を使わない
- 略語を使用する
- 最後に r を追加する
*** パッケージを作成する
以下を実行
#+BEGIN_SRC R
devtools::create("mytestpkg")
#+END_SRC

#+RESULTS:
: TRUE


以下が生成
- R/: [[*R%E3%82%B3%E3%83%BC%E3%83%89][第3章 Rコード]]で説明
- DESCRIPTION: [[*%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8%E3%81%AE%E3%83%A1%E3%82%BF%E3%83%87%E3%83%BC%E3%82%BF][第4章 パッケージのメタデータ]]で説明
- NAMESPACE: [[*%E5%90%8D%E5%89%8D%E7%A9%BA%E9%96%93][第8章 名前空間]]で説明
*** Rstudio プロジェクト
*** パッケージとは
5種類ある．
**** ソースパッケージ
自身のマシンの中の開発バージョンのこと．
**** バンドルパッケージ
.tar.gzの形で1つのファイルに圧縮されたもの．
必要になったときには，devtools::build() すれば生成する．
バンドルパッケージソースパッケージと似ているが，は以下のような特徴がある
- vignetteがビルドされていて，.md や.tex ではなく，HTML や PDF の出力が作成されている．
- ソースパッケージに開発高速化のための一時ファイルが入っていない．
- .Rbuildignore にリストされたファイルが取り除かれている
***** ignore すべきファイル
- .Rproj
- .Rproj.user
- README.Rmd
- cran-comments.md
- NEWS.md
- .travis.yml
**** バイナリパッケージ
R パッケージ開発ツールを持っていないユーザに配布する場合の形．
ただし，プラットフォームに依存する．
内部構造はソースパッケージとかなり違う．
- R/ には .R ファイルがない．そのかわり，関数が読み込まれ，最適なファイル形式で保存されている．
- Meta/ にたくさんの Rds ファイルがアク．
- html/ にヘルプに必要なファイルがある
- src/ が libs/ に変わり，コンパイル結果が入っている
- inst/ が最上位に移動している
**** インストール済みのパッケージ
**** インメモリパッケージ
ロードされ，検索パスにアタッチされたパッケージ．
*** ライブラリとは
インストール済みのパッケージを含むディレクトリのこと．
**** library() と require() の違い
library() はパッケージが見つからないときエラーを返す．
ただし，パッケージを開発する時にはどちらもパッケージ内で*絶対に使用してはいけない*!!
* パッケージコンポーネント
パッケージの各コンポーネントについての説明．
** Rコード
ディレクトリR/
*** Rコードのワークフロー
パッケージを使う利点の一番は，devtools::load_all() でコードを一括リロードできること．
やってみよう
**** コードを作る
#+BEGIN_SRC sh
echo 'greet <- function(name) {print(paste0("hello, ", name, "!"))}' > mytestpkg/R/hello.R
cat mytestpkg/R/hello.R
#+END_SRC

#+RESULTS:
| greet <- function(name) {print(paste0("hello | , name, !"))} |
**** リロードする
#+BEGIN_SRC R :session *R:study*
devtools::load_all("../../mytestpkg")
greet("akira")
goodbye("Akira", 1)
goodbye("Akira", 2)
goodbye("Akira", 3)
#+END_SRC

#+RESULTS:

*** 関数をまとめる
要件
- 全ての関数を1つのファイルにしてはいけない
- 関数ごとにファイルを作ってはいけない
*** コードスタイル
Google のスタイルがおすすめ．
**** オブジェクト名
変数と関数の名前
- 小文字にする
- ドットではなく（S3 メソッドとかぶる），アンダースコアで区切る（一貫性があるならキャメルも可）
- 変数名は名詞であるべき
- 関数名は動詞であるべき
**** スペース
演算子の前後にはスペースを入れる
**** 中括弧
- 開き中括弧だけで終わらない
- 後ろに else がある時をのぞき，閉じ中括弧は独立させる
**** 行の長さ
1行80字
**** インデント
スペース2つ．タブは禁止．
**** 割当て
= ではなく，<- を使用すること．
**** コメントのガイドライン
what ではなく，why を書くように心がける．
- と = を使用してファイルを読みやすく分割する
*** トップレベルのコード
「スクリプト」と「パッケージのコード」の違い
- 実行タイミング: コードはsource()でロードされた時に実行される．パッケージでは，コードはビルドされた時に実行される．
- 状況: パッケージのコードは，想像もしなかったような状況で使われることもある．
**** コードのロード
***** パッケージの場合
トップレベルのコードはビルド時にしか実行されない．
#+BEGIN_SRC R
  library(ggplot2)                        #ここはビルド時にしか実行されない

  my_function <- function() {
    print("foo")
  }
#+END_SRC
**** Rの景観
ユーザの景観を変えてはいけない．
コードを理解するのが難しくなってしまうから．
***** 絶対にやってはいけないこと
- library()
- require()
- source()
***** 注意が必要なこと
最後に on.exit() を使ってクリーンアップすること．
- options()
- par()
- setwd()
**** 副作用が必要なのはどのようなときか                           :難しい:
時折，副作用が必要になることがある．
例えば，ロード時に初期設定をする必要があるとき．
**** S4クラス，ジェネリック，メソッド                             :難しい:
正しい順番で呼び出す必要がある．
*** CRAN に関する補足
ASCII文字だけを使うこと．
Unicode も使えるが，エスケープが必要になる．
** パッケージのメタデータ
file:mytestpkg/DESCRIPTION が説明すること
- 作成したパッケージが何を解決するのか
- 誰がパッケージを使えるのか
- 不具合発見時の連絡先
*** 必要最小限の DESCRIPTION を自動的に生成する
#+BEGIN_SRC R
devtools::create("mytestpkg")
#+END_SRC

#+RESULTS:
**** たくさんのパッケージを書くなら
以下をグローバルに設定可能．
- devtools.desc.author
- devtools.desc.license
- devtools.desc.suggests
- devtools.desc
**** DESCRIPTION の書式
Debian 制御書式（DCF）
フィールド名: 値
インデントはスペース4つ．タブは不可．
*** 依存関係: バッケージには何が必要か
#+BEGIN_SRC R
  devtools::use_package("beepr", "imports", "mytestpkg")
#+END_SRC

#+RESULTS:
devtools::use_package()とすると，自動的に Imports を DESCRIPTION に追加できる．
Suggests を追加したければ
devtools::use_package("package", "Suggests")．
***** Imports
パッケージ可動作するために「必要」なパッケージ．
ここにリストアップされたものは自動的「インストール」されるが，「ロード」はされない．
外部パッケージの関数を使う時には，package::function() の形で書くこと．
***** Suggests
ここに記載されたパッケージを「使うことができる」．
自動的にインストールはされない．
vignetteをビルドするためのサンプルデータセットを使うときなど．
**** バージョン管理
特定のバージョンに依存している時には，括弧書きでバージョンを指定する．
Imports:
    dplyr (>= 0.3.0.1)
など．
**** その他の依存関係
***** Depends
昔使われていた表記．今は常に Imports を使うべき．
例外は第8章で学ぶ．
***** LinkngTo
他のパッケージ中の C や C++ のコードに依存している．
***** Enhances
Suggests の逆．
自分が，他のパッケージの機能を高めていることを表明する．
わかりにくいので非推奨．
*** Title と Description: パッケージは何をするのか
両者は長さだけが異なる．
**** Title
パッケージ内容を1行で説明したもの．
- 65文字以内
- ピリオドなし
- 単語毎にキャピタライズ
**** Description
Title よりも詳細に説明．複数の文を使える．
- 1段落に収める．
- 各行は80文字以内
- 2行目以降は，スペース4つでインデント
*** 作成者: 開発したのは誰か
Authors@R person("Akira", "Hayashi", email = "akira.hayashi.1987@gmail.com",
role = c("aut", "cre"))
- aut: 著者
- cre: 保守担当者
- ctb: 貢献者
- cph: 著作権者．著作権が著者以外（企業などの著者の雇用主）に保有されているとき使う．
**** CRAN では
CRAN からの問い合わせにメールアドレスを使う．
*** ライセンス: パッケージを使えるのは誰か
Hadleyの見解では，ライセンスの候補は多分3つ．
- MIT: シンプルで寛容．ライセンス一緒なら，自由に再配布可能．
- GPL-2 か GPL-3: 再配布時には，GPL 準拠の方法でライセンスしなければならない．
- CC0: コードとデータ，全ての権利を放棄
**** CRAN では
公式HPにライセンス一覧がのっている．
*** バージョン
. （一応 - も使える）で区切られた整数を少なくとも2つ並べること．
- リリースしたバージョン: major.minor.patch
- 開発中のパッケージ: 最後に9000を付ける．0.0.0.9000のように．
*** その他のコンポーネント
**** Collate
.R をロードする順番を制御．
副作用を持つような時に使う．
[[*S4][5.7.2 S4 ]]で説明する
**** LazyData
パッケージ内のデータにアクセスしやすくなる．
[[*%E5%A4%96%E9%83%A8%E3%83%87%E3%83%BC%E3%82%BF][第9章 外部データ]] で説明
** オブジェクトのドキュメント
roxygen2を使った文書化: 他の人々（未来の自分も含む）に，パッケージ内の特定の関数の使い方を理解してもらうため
コードとドキュメントを一緒に作れる
作成したパッケージ内の各関数の細かく詳細な情報を記述する

ただし，全てについてドキュメントは書かなくていい．
ドキュメントを書くのは，[[*%E3%82%A8%E3%82%AF%E3%82%B9%E3%83%9D%E3%83%BC%E3%83%88][エクスポート]] したオブジェクトだけでいい．．

**** vignette とはどう違うか？
既にオブジェクトの名前を知っているときにしか使えない．
特定の問題を解決するオブジェクトを探すときはvignette．
**** どうやるの？
適切な書式でコメントを書けば，roxygen2 が自動で .man/ の中にRdファイルを作ってくれる．
**** roxygen2 を使うメリット
- コードとドキュメントが混在しているので，コードを修正したあとで，その部分のドキュメントを修正するのを忘れにくい
- オブジェクトを動的に調査し，定型文を自動的に生成する
- 異なる種類のオブジェクトのドキュメントの違いを自動的にまとめてくれるため，枝葉を学ぶ必要がない
*** ドキュメントのワークフロー
**** 4つのステップ
- .Rファイルに roxygen コメントを追加する
- devtools::document() を実行
- ドキュメントを?でプレビューする
- ドキュメントが望ましい状態になるまでこれを繰り返す
**** やってみよう
[[file:mytestpkg/R/goodbye.R::#'%20%E6%8C%A8%E6%8B%B6%E3%82%92%E3%81%99%E3%82%8B%EF%BC%8E][Goodbye関数]]
[[/Users/ahayashi/Documents/GitHub/study/R/mytestpkg/R/hello.R][greeting関数]]

#+BEGIN_SRC R :session *R:study*
devtools::document("../../mytestpkg")
library(mytestpkg)
?goodbye
?greet
#+END_SRC

#+RESULTS:

*** その他のドキュメントのワークフロー
ページ間リンクはできない．
Rstudio ではビルドペインの Build & Reload をクリックするらしい．
コマンドラインではどうやるのだろう．
*** roxygen コメント
#'で始まり，関数よりも前に書く必要がある．
@が重要なシンタックスなので，@自体を出力したいときには@@とエスケープする必要がある．
**** 基本的な書き方
#+BEGIN_SRC R
  #' The title start with uppercase and end with period.
  #'
  #' @param name 相手の名前
  #' @param type 挨拶の種類
  #' @return \code{\link{greet}}のあとにする，\code{name}への\code{type}個めの挨拶
  #' @examples
  #' goodbye("John", 1)
  #' goodbye("Mary", 2)
  goodbye <- function(name, type) {
    if (type == 1) {
      greeting <- "Goobye"
    } else if (type == 2) {
      greeting <- "Adios"
    } else {
      greeting <- "See you"
    }
    print(paste0(greeting, ", ", name, "."))
    beepr::beep(1)
  }
#+END_SRC
**** その他の tips
- @seealso: 有用な情報源を参照する．リンクは自分で貼らねばならない．
- @family: 関連する関数の系列を複数形で書く．今はまだ意味がわからない．
- @aliases: ?を使って指定できるトピックの別名．検索性を向上させる．
- @keywords: 事前に定義されているものから選ばないといけないらしい．今はまだ意味がわからない．
*** 関数のドキュメント
関数についてのドキュメントがいちばん多くなるだろう．
- @param: 入力について簡潔に説明．大文字で始め，ピリオドで終わる．
- @examples: 関数を実際にどのように使うのかを示す．R CMD check で自動テストされるので，エラーがないように．
- @return: 重要度は低いが，関数が入力によって異なる型の出力を返す場合や，S3, S4, RC オブジェクトを返すような場合には書いたほうがいい．
*** データセットのドキュメント
[[*%E3%83%87%E3%83%BC%E3%82%BF%E3%82%BB%E3%83%83%E3%83%88%E3%81%AE%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88][9.1.1 データセットのドキュメント]] を参照．
*** パッケージのドキュメント
パッケージ全体のヘルプを作ると，vignette を補完するものとして役立つ．
package?foo のようにアクセスされる．
パッケージに対応するオブジェクトは無いので，手作業でラベルを打つ．
**** どうやって？
package-name.R に書くと良い．

ちなみに，ここには，（特定の機能だけではなく）パッケージレベルのインポート文を書くのに適している．
インポートについては，[[*%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88][8.6 インポート]] で学ぶ．
*** クラス，ジェネリック，メソッドのドキュメント
使用しているオブジェクトシステムによって違う．
以下，順にみていく．
**** S3
S3のジェネリックは通常の関数なので，ドキュメントも関数として扱う．
S3クラスには公式な定義がないので，コンストラクタ関数についてドキュメントを作る．
S3メソッドについてドキュメントを書くかどうかは自分次第．
例を見たければ，predict.lm(), predict.glm(), anova.glm()などの複雑なメソッドのドキュメント例を見ることができる．
**** S4
S4のジェネリックも関数なので，ドキュメントも関数として扱う．
しかしこちらはやや複雑．
S3と違って，S4は必ずドキュメントを作成しないとだめ．
各メソッドごとに独自のドキュメントを作るのはいやだろう．
その代わりに，開発状況に応じて以下の3オプションから選択し，そこにドキュメントを記載せよ．
- クラス内: 対応するジェネリックが1つのディスパッチを使用していて，そのクラスを作ったのが自分であるとき
- ジェネリック内: ジェネリックが複数のディスパッチを使用していて，そこで使われるジェネリックもメソッドも，自分が作ったものであるとき
- 独自ファイル内: メソッドが複雑なとき，またはメソッドだけは自分が書いたが，クラスやジェネリックを書いたのは自分でないとき

@rdname や @describeIn を使って，メソッドのドキュメントがどこにあるかを制御する．
詳細は [[*%E8%A4%87%E6%95%B0%E3%81%AE%E9%96%A2%E6%95%B0%E3%82%92%E5%90%8C%E3%81%98%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%81%AB%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E5%8C%96%E3%81%99%E3%82%8B][5.9.2 複数の関数を同じファイルにドキュメント化する]] を参照．

また，S4 では，コードは一定の順序で実行しなければならない点に注意．
普通，R はアルファベット順にコードを実行してしまうので，
@include タグを使って，現在のファイルより前にロードすべきファイルをスペース区切りで指定する．
**** RC （Reference class，参照クラス）
S3やS4とは違う．
メソッドがクラスに関連づけられていて，ジェネリックに関連していない．
RCも，ドキュメント化において独自の慣習，docstring がある．

クラスごとに roxygen ブロックを1つ書けばいいだけなので，S4よりは簡単．
@slot ではなく，@field を使う点にも注意．
*** 特殊文字
- @: roxygen タグの開始を示す．
- %: 文末まで続くLaTeXコメントの開始を示すために使う．%自体を挿入するには\%．
- \: LaTeX エスケープの開始を示す．\を挿入したければ\\．
*** Do Repeat Yourself
同じことを書くのはイライラする．
- @inheritParams
- @describeIn または @rdname
が助けてくれる．
**** パラメータを他の関数から継承する
今書いている関数のパラメタが，既に定義した関数のドキュメントで使われている場合，
@inheritParams を使えばいい．
**** 複数の関数を同じファイルにドキュメント化する


*** テキスト書式参照表
**** 文字の書式
**** リンク
**** リスト
**** 数式
**** 表
** vignette: 長文形式のドキュメント
詳細な情報ではなく，全体像を描く．
複数のコンポーネントをどのように組み合わせれば問題を解くことができるを説明する．
- Rmarkdown
- knitr
を使う．

vignette は本の章や学術論文のようなもの．
パッケージが解決しようとしている問題を説明し，どうやってその問題を解決するかを読者に提示する．

複数の関数をわかりやすいカテゴリに分割し，それらがどう協調して問題を解決するかを示す．

browseVignettes() で，インストール済のすべての vignette を見ることができる．
特定のパッケージのについて見るには，引数としてパッケージ名を与える．

以前は LaTeX と協調する Sweave を使うしかなかったが，現在の主流は knitr．
knitr は以下の理由からおすすめ．

- Markdown を使える．機能に制限があるが，逆にそのおかげで内容に集中できる
- テキストとコード，その実行結果を混在させることができる
- rmarkdown パッケージを使ってさらに簡単になる．pandoc が Markdown を HTML に変換する．テンプレートもたくさん提供することで，Markdown と knitr とをよく統合している．


*** vignette ワークフロー

**** 最初の1回
#+BEGIN_SRC R :results output
  devtools::use_vignette("my-vignette", "mytestpkg")
#+END_SRC

#+RESULTS:
上のコードを実行することによって，以下が自動で実行される．
- vignettes/ ディレクトリを作成する
- DESCRIPTION に必要な依存関係を追記する（Suggests と VignetteBuilder フィールドに knitr を追記する）
- vignette の草稿版である vignettes/my-vignette.Rmd を作成する

**** その後のワークフロー
- vignette を修正する
- knitr::knit("mytestpkg/vignetts/my-vignette.Rmd") とする（多分）

**** vignette の3つの主要なコンポーネント
- 最初のメタデータブロック
- テキストの書式に使う Markdown
- テキストとコード，結果を混在させるための knitr
それぞれ見ていく．

*** メタデータ
YAML で書いてある．
フィールド名とコロン．

注意すべきは ">"．
この後に続くテキストの行がプレーンテキストで，
他の YAML の特殊な機能を使うべきではないことを意味する．

**** title, author, date
タイトルブロックが先頭に欲しくない場合は削除してもいい．
日付はデフォルトの値が入っている．
後述の構文を使えば，作成日の日付にすることができる．
**** output
rmarkdown に対して，どの出力フォーマットを使うかを指定している．
- HTML
- PDF
- スライドショー
などがある．
**** vignette
- \VignetteIndexEntry: 目次に表示されるべきタイトルを記入する．
- 他の2行: knitr を使用することと，エンコーディング情報が書いてあるので，いじらず，そのままにしておく．

*** Markdown
ほどよく読みやすく，書きやすい．
出力していない状態でも書きやすい．
**** セクション
見出しは#．

3つ維持位うのハイフン，アスタリスクは水平罫線になる．
**** リスト
***** 順序なしリストはアスタリスク．
インデントはスペース4つ．

複数段落のテキストも，リストの項目として配置できる（個人的にはあまりいいとは思わない）．

***** 順序有りのリスト
1. を使う．

***** 混在も可能
スペース4つのインデントルールを守っていれば，順序あり/なしリストを混在させて使える．

**** インライン書式
- イタリック: アンダースコアかアスタリスクで挟む
- 太字: アンダースコアかアスタリスクを2個ずつ使って挟む
- リンク: [テキスト](リンク先)，または<リンク先>

**** 表
| 右寄せ | 左寄せ | 中央寄せ  | デフォルト |
| -----: | :----- | :-------: | --------   |
|        |        |           |            |

**** コード

***** インラインコード
文章の途中で`code`とする．

***** 大きいコードブロック
```
# このように，3つのバッククォートを使う．
add <- function(a, b) a + b
```

****** 他言語シンタックス
いろいろな言語がサポートされている．

```c
# このように，3つのバッククォートの後ろに言語名を書く．
int add(int a, int b) {
  return a + b;
}
```

```{r}
# ただし，R の場合には中括弧を使わねばならない．
# こうすることで，knitr によって特別な処理がなされる．
add <- function(a, b) a + b
```
*** knitr
knitr を使うと，コードと結果，テキストを混在させることができる．
knitr は，
- R のコードを実行
- 結果を取得
- Markdown に変換
する．

knitr は，R からの全ての出力結果を補足する．
つまり
- メッセージ
- 警告
- エラー
- プロット
を補足する．

**** オプション

***** 1つのブロックの設定だけを変更したいとき
ブロック設定を追加する．

```{r, out1 = val1, opt2 = val2}
# code here
```

***** 全てのブロックを変更したいとき
knitr::opts_chunk$set() を knitr ブロックで呼び出し，パラメタを設定する．

```{r, echo = FALSE}
knitr::opts_chunk$set(
  opt = val1,
  opt = val2
)
```


***** 重要なオプションたち

****** eval = FALSE
コードが評価されないようにする．
実行に時間がかるようなコードに便利．

ただし，コードが実行されないため，バグの原因になりやすいので注意．

****** echo = FALSE
コード自体が文書に出力されないようにする．
ただし，vignette のそもそもの目的に鑑みれば，このオプションは利用すべきではない．

レポートに使う場合にはいいかもしれない．

****** results = "hide"
出力の描画が停止される．

****** warning = FALSE, message = FALSE
警告とメッセージの表示を抑制する．

****** error = TRUE
ブロック内のどんなエラーも補足し，インライン表示する．
どんなエラーを投げるかを実演したいときに便利．

ただし，これを TRUE にするときには，常に purl = FALSE も使わなければならない．
でないと，エラーの文がR に渡されてしまう．

****** collapse = TRUE, comment = "#>"
コードの出力を表子するときにとても便利．
R によるデータサイエンスでも使われていた．
[[*%E5%85%A8%E3%81%A6%E3%81%AE%E3%83%96%E3%83%AD%E3%83%83%E3%82%AF%E3%82%92%E5%A4%89%E6%9B%B4%E3%81%97%E3%81%9F%E3%81%84%E3%81%A8%E3%81%8D][全てのブロックを変更したいとき]] の方法を使って，グローバルに設定しておくといい．

****** results = "asis"
R コードの出力を Markdown のリテラルのように扱う．
R コードから表を作るときにも便利．

****** fig.show = "hold"
全ての図をコードブロックの末尾に表示するようにする．

****** fig.width = 5, fig.height = 5
インチ単位で指定．

****** その他のオプション
公式 HP 参照のこと．
*** 開発サイクル
**** 普通のやり方
#+BEGIN_SRC R
devtools::build("./mytestpkg")
#+END_SRC

#+RESULTS:
: /Users/ahayashi/Documents/GitHub/study/R/mytestpkg_0.0.0.9000.tar.gz
**** どうしても vignette だけをビルドしたいなら
なぜ非推奨なんだろう．
コードとドキュメントに乖離が生じうるからかな？
#+BEGIN_SRC R
devtools::build_vignettes("./mytestpkg/")
#+END_SRC

#+RESULTS:
: TRUE
*** vignette を書くためのアドバイス
「思ったことを書いていないならば，それは思ったと思っているだけである．」 --Leslie Lamport (LaTeX の開発で知られる数学者)

vignette を書くということ，すなわち，誰かに自分のパッケージの使い方を教えているということ．
自分を読者の立場に置き，「初心者の気持ち」に合わせる必要がある．
しかし，これはとても難しい．
**** どうするか？
直接，人に教えるといい．
自分の vignette に対するフィードバックを得るためのいい方法である．
- すぐにフィードバックを受けられる
- 他の人がすてに知っていることを判断するのも簡単になる
**** 嬉しい副作用
自分のコードの改善にも役立つ．
強制的に，最初に学習する人が行う内容を再確認することになり，他の人が難しいと感じる部分を知ることができる．

導入方法に関する説明を書く時に，いくつかの重要な機能を見落としていることに度々気づく．
それらを追加すれば，利用者を手助けできるだけでなく，自分にも役立つ．
本を書くのも，これと似ている．

**** Hadley おすすめのブログ
***** "Creating Passionate Users" by Kathy Sierra
http://headrush.typepad.com

プログラミングに関する助言に満ちている．
古い内容から，全て読むことを，心からおすすめする．

***** "Serious Pony" by Kathy Sirra
http://seriouspony.com/blog/
素晴らしい記事がいくつかある．


***** "Style: Lessons in Clarity and Grace" by Joseph M. Williams and Joseph Bizup
書きものの構造を理解する助けとなる．
悪い書物とは何か，がわかる．

**** vignette 執筆はいい息抜き
書きものは，コーディングとは違う脳の使い方をする．
構造化された先延ばしという考え方．
http://www.structuredprocrastination.com
**** 統合

シンプルなパッケージなら，vignette は1つで十分．

複雑なパッケージなら，2つ以上必要かも．
必要なら，好きなだけ作ることができる．

vignette は，いわば本の章のようなもの．
各々が自己完結していて，しかも密接した1つの全体をなすものとしてつながっている．
***** うまいリンクの貼り方
vignette がどのように保存されているかに着目してリンクを貼る．
abc.Rmd にリンクを貼りたければ，abc.html に対するリンクを作る．
*** CRAN に関する補足                                              :難しい:
vignette はローカルにビルドする．
CRAN は HTML/PDF やそのソースコードだけを受け取るが，再ビルドは行わない．

以下，今はまだ読んでもわからなかった．p.78
*** 次に行くべき場所
vignette の見た目を細かく調整したいなら，R Markdown の公式サイトをチェック．

素晴らしい vignette が書けたら，Journal of Statistical Software や The R Journal などに投稿してみては．
レビュアーからのコメントが，自分の vignette やソフトウェアの品質向上に役立つ．

** テスト
testthat を使い，非公式な対話的テストを公式な方法で自動化する
- 作成したパッケージが期待通りに機能することを保証するため
- 変更を加えてもそれが機能し続けるため
これまでより多く少し多くの仕事に時間を投資する必要があるかもしれない．
でも，その投資は次の4つの点で利益を生む．

*** バグが減少する
コードの振る舞いを明確に定義することになるので，バグが減少する．

コードの振る舞いをコードとテストの2個所に書くので，片方の記述をもう片方の記述と比較してチェックすることができる．
複式簿記による記帳に誤りが少ないのと，原理的に似ている．

*** コードの構造が良くなる
テストをしやすいコードは，良い設計になっている．
テストコードを書くためには，複雑なコードを機能ごとに整理し，単独で実行可能なパーツへ分解することになるから．
結果として，関数は
- テストしやすく
- 理解しやすく
- 使いやすく
なる．
別の方法（なんだろう）で，それらの関数を組み合わせやすくもなる．

*** コーディングの再開が容易になる（テスト駆動開発）
コーディングをやめる時に，失敗するテスト，例えば，
次に実装したい機能のためのテスト
を必ず作るようにしておくと，テストの実施によって，やめたところから再開するのが簡単になる．
テストが，次に何をすればいいかを教えてくれる．

*** 堅牢なコードになる
自分のパッケージの主要機能を検証するテストを持っておけば，
コードを壊してしまう危険を気にすることなく，自信を持ってコードに大きな変更を加えることができる．

実装内容をシンプルにすることができると思いついた時，特に威力を発揮する．
勇気を持って，断捨離できるから．

ただし，他の言語の単体テストに慣れていると違和感を感じるかも．
それはR はオブジェクト指向ではなく，関数型プログラミング言語に近いため．
R の主要なオブジェクト指向システムは，ジェネリック関数（つまり，メソッドはクラスではなく，関数に属している）をベースにしていて，
オブジェクトとそのメソッドに対するテストをする，というやり方は意味がないから．

*** テストのワークフロー

**** セットアップ
#+BEGIN_SRC R
devtools::use_testthat("mytestpkg")
#+END_SRC

#+RESULTS:
: TRUE
上のコードによって，以下が自動的に実行される．
- test/testthat/ を作成する
- DESCRIPTION の Suggests フィールドに，testhat を追加する
- test/testthat.R を作成する．これは，R CMD check の実行時に，全てのテストを一括実行してくれる．

**** セットアップ後のワークフロー
- コードやテストを修正する
- devtools::test() でパッケージをテストする．
- 全てのテストが成功するまで繰り返す．


**** テストの実行結果の見方
Expectation : ........
rv : ....
Variance : ......123.45.

1行が1つのテストファイルに対応している．
各.は成功したテストを表している．
各数値は，失敗したテストを表している．数値は，失敗したテストの詳細情報のリストのインデックス番号に対応する．

*** テストの構造
テストのファイルは tests/testthat/ にある．
テストファイルのファイル名は test で始める必要がある．

テストは階層構造を持っている．
- ファイル
  - テスト
    - 期待値
    - 期待値
    - 期待値
  - テスト
    - 期待値
    - 期待値
  - テスト
    - 期待値
- ファイル
  - テスト
  - ...

**** どう構造化されているか

***** レベル1/ 期待値の検証
テストの核となる，expect_何々，の部分．
計算の結果，期待されることを書いておく．
- 正しいクラスの正しい値になっているか
- 正しくエラーメッセージが出ているか
結果をコンソールで目視確認する，という行為を自動化している．
次の節でより詳細に説明する．

***** レベル2/ 1つのテスト
複数の期待値の検証をグループとしてまとめる．
単体の機能ごとにテストを行う（単体テスト）．

- 単純な関数の出力を検証
- より複雑な関数のとあるパラメータが取りうる範囲を検証
- 複数の関数にまたがって強い関係のある機能を検証
など．

テストは test_that() で作成する．

***** レベル3/ テストファイル
関連するテストをグループとしてまとめる．
context() を使って，人間が読みやすい名前を付けておく．

**** 期待値の検証
テストにおいて一番重要な要素．
- 期待値を検証する関数の名前は expect_ で始まる．
- 期待値を検証する関数は，引数を2つとる．1つめは，テスト対象の機能が実際に返す結果，2つめは期待する結果．
- 実際に返す結果と期待値が一致しない時，testthat はエラーを返す．

期待値検証のコードはファイルに組み込むが，対話的に実行することもできる．
ただ，やりすぎると元のアドホックなテストに戻ってしまうが．

およそ20個の期待値検証用の関数がある．
以下，重要なものを見ていく．

***** expect_equal()
最もよく使われる．
数値の許容誤差を含んで，等価性を検討するときには，all.equal() を使う．

***** expect_identical
真に同一かどうかを検証する．

***** expect_match()
正規表現と文字ベクトルがマッチするかどうか．

似たような検証関数が3つある．
- expect_output(): 出力結果
- expect_message(): メッセージ
- expect_warning(): 警告
- expect_error(): エラー
をそれぞれ検証する．

***** expect_is()
オブジェクトが特定のクラスを継承してるかをチェックする．
expect_is(model, "lm") など．

***** expect_true(), expect_false()
ふさわしい検証関数がないときに有効な汎用の検証関数．

***** expect_equal_to_reference()
最初の実行した時に結果をキャッシュし，その後に実行されたときに同じ結果になるかどうかを検証する．
- 振る舞いを正確に知らない場合
- 複雑すぎるため検証コードで簡単に再現できないとき
に使う．

何らかの理由により，結果が本当に変わる場合には，キャッシュを削除して再テストを実施する．
*** テストを書く
テストにはわかりやすい名前を付け，[[*%E3%83%AC%E3%83%99%E3%83%AB2/ 1%E3%81%A4%E3%81%AE%E3%83%86%E3%82%B9%E3%83%88][1つのテスト]]は1つの機能の検証のみを行うようにするべき（単体テスト）．
なぜか？
テストが失敗したときに，何が悪く，それがどこで発生しているのかを知ることができるから．

新しいテストは test_that() で作成する．
test_that("Test that...(テストの名前)", テストコードたち)

1つのテストにあまりたくさんの検証を詰め込みすぎない方がいい．
なぜなら，テストが失敗したときに原因個所特定が早くなるため．
わかりやすいメッセージをテストに関連付けるといい（どういう意味だろう）．
***** テストと環境
テストは独自の環境で実行され，テスト内で自己完結している．
でも，testthat 自体は，テスト内のアクションが R の環境に与えた影響をクリーンアップする方法を知らない．

テストを作成する人自身が，R の基本機能を使って環境をクリーンアップする必要がある．

ちなみに，テストが外の環境に与える影響は，以下．
- ファイルシステムへの影響: ファイルの作成，削除，ディレクトリ移動など
- 検索パスへの影響: library() や attach() の使用による検索パスの変化
- グローバルオプションの変更: options() や par() による変更
**** 何をテストするか
「何らかの情報をコンソールへ出力したくなったとき，あるいはデバッグ用のコードをかきたくなったときには，それをテストとして書くべきである」 --Martin Fowler

テストを書くということは，トレードオフでもある．
- コードを不注意によって変更してしまうことは少なくなる
- 一方，コードを簡単に変更できなるということでもある

テストの書き方に関して，アドバイス．
***** 「外部」に提供するインターフェースをテストする
内部向けのインターフェースに対してもテストを書いてしまうと，内部機能を変更する度に，テストの方も更新しなくてはならなくなる．
***** 1つのテストでは1つの振る舞いのみをテストする
後になって振る舞いを変更する際に，その1つの振る舞いを対象としたテストを直すだけで済む．
***** ばかばかしいほど単純なコードはテストしない
- 正常に動作するか確信が持てないコード
- 不安定なコード
- 複雑な相互依存性を持つコード
のテストに注力する．

とはいえ，「これは単純なのでテストはいらない」と思ったときにこそ，ミスすることが多い．注意せよ．
***** バグを発見したときには必ずテストを書く．
テスト駆動開発は有効なアプローチ．
常にテストを書くことから始めて，そのテストを通過するようにコードを作成する．

一般的な問題解決フローと全く同じ．
「問題が解決できたかどうかを把握するためには，その成功の条件を確立することから始める」
深い．
**** テストをスキップする
関数の機能によっては，テストを実行できないタイミングがある．
- インターネットに接続していないとき
- テストのために必要なファイルがないとき

こんなとき，テストをスキップしたいだろう．
そのときは，以下のようにskip() を使う．

check_api <- function() {
  if (not_working()) {
    skip("API が利用できません")
  }
}
**** 独自のテストツールの作成
テストをたくさん書くようになると，同じコードを何度も書く様になってくる．
こんなときは，テストの共通の振る舞いを抽出し，新しい関数に切り出すといい．
***** 例: library(lubridate) の floor_date() 関数のテスト
日付データに対して，最も近い秒・分・時への丸め込みのチェックをしている．

たくさんの重複コードがあり，これ自体もバグ増加の原因になり得る．
****** 重複除去前
#+BEGIN_SRC R
  test_that("floor_date は異なる単位でも機能する", {
    base <- as.POSIXct("2009-08-03 12:01:59.23", tz = "UTC")

    expect_equal(floor_date(base, "second"),
                 as.POSIXct("2009-08-03 12:01:59", tz = "UTC"))
    expect_equal(floor_date(base, "minute"),
                 as.POSIXct("2009-08-03 12:01:00", tz = "UTC"))
    expect_equal(floor_date(base, "hour"),
                 as.POSIXct("2009-08-03 12:00:00", tz = "UTC"))
    expect_equal(floor_date(base, "day"),
                 as.POSIXct("2009-08-03 00:00:00", tz = "UTC"))
    expect_equal(floor_date(base, "week"),
                 as.POSIXct("2009-08-02 00:00:0", tz = "UTC"))
    expect_equal(floor_date(base, "month"),
                 as.POSIXct("2009-08-01 00:00:0", tz = "UTC"))
    expect_equal(floor_date(base, "year"),
                 as.POSIXct("2009-01-01 00:00:0", tz = "UTC"))
  })
#+END_SRC
****** ヘルパー関数を2つ作る
純粋に文字数が少なくなり，各検証を1行で書けるようになった．
#+BEGIN_SRC R
  test_that("floor_date は異なる単位でも機能する", {
    base       <- as.POSIXct("2009-08-03 12:01:59.23", tz = "UTC")
    floor_base <- function(unit) floor_date(base, unit)
    as_time    <- function(x) as.POSIXct(x, tz = "UTC")

    expect_equal(floor_base(base, "second"), as_time("2009-08-03 12:01:59"))
    expect_equal(floor_base(base, "minute"), as_time("2009-08-03 12:01:00"))
    expect_equal(floor_base(base, "hour"),   as_time("2009-08-03 12:00:00"))
    expect_equal(floor_base(base, "day"),    as_time("2009-08-03 00:00:00"))
    expect_equal(floor_base(base, "week"),   as_time("2009-08-02 00:00:00"))
    expect_equal(floor_base(base, "month"),  as_time("2009-08-01 00:00:00"))
    expect_equal(floor_base(base, "year"),   as_time("2009-01-01 00:00:00"))
  })

#+END_SRC
****** 期待値検証関数を作る
さらに短く，わかりやすくできた．
ただし，期待値の検証が失敗したときに，わかりやすいメッセージが出なくなる（あとで解決）．
#+BEGIN_SRC R
  test_that("floor_date は異なる単位でも機能する", {
    base       <- as.POSIXct("2009-08-03 12:01:59.23", tz = "UTC")
    as_time    <- function(x) as.POSIXct(x, tz = "UTC")

    expect_floor_equal <- function(unit, time) {
      expect_equal(floor_date(base, unit), asPOSIXct(time, tz = "UTC"))
    }

    expect_floor_equal("second", "2009-08-03 12:01:59")
    expect_floor_equal("minute", "2009-08-03 12:01:00")
    expect_floor_equal("hour",   "2009-08-03 12:00:00")
    expect_floor_equal("day",    "2009-08-03 00:00:00")
    expect_floor_equal("week",   "2009-08-02 00:00:00")
    expect_floor_equal("month",  "2009-08-01 00:00:00")
    expect_floor_equal("year",   "2009-01-01 00:00:00")
  })

#+END_SRC
****** わかりやすいメッセージが出るようにする
bquote() と eval() を使う必要がある．
bquote() の中で，.(x) という書き方をしている．
すると，() の中身が呼び出し時に挿入される．
#+BEGIN_SRC R
  expect_floor_equal <- function(unit, time) {`
    as_time <- function(x) as.POSIXct(x, tz = "UTC")
    eval(bquote(expect_equal(floor_date(base, .(unit)), as_time(.(time)))))
  }
#+END_SRC
****** 完成
#+BEGIN_SRC R
  test_that("floor_date は異なる単位でも機能する", {
    as_time            <- function(x) as.POSIXct(x, tz = "UTC")
    expect_floor_equal <- function(unit, time) {
      eval(bquote(expect_equal(floor_date(base, .(unit)), as_time(.(time)))))
    }

    base <- as.POSIXct("2009-08-03 12:01:59.23", tz = "UTC")

    expect_floor_equal("second", "2009-08-03 12:01:59")
    expect_floor_equal("minute", "2009-08-03 12:01:00")
    expect_floor_equal("hour",   "2009-08-03 12:00:00")
    expect_floor_equal("day",    "2009-08-03 00:00:00")
    expect_floor_equal("week",   "2009-08-02 00:00:00")
    expect_floor_equal("month",  "2009-08-01 00:00:00")
    expect_floor_equal("year",   "2009-01-01 00:00:00")
  })

#+END_SRC

#+RESULTS:

*** テストファイル
テストの構造上の最上位に位置するのがテストファイル．
テストに関する簡潔な説明を準備し，context() を使って定義する．

全部のテストを1つのテストファイルに入れてはいけない．
まずは，複雑な関数ごとにテストファイルを作るといい．
*** CRAN に関する補足
CRAN は，全てのテストをCRAN　のプラットフォーム（Win, Mac, Linux, Solaris）上で実行する．
以下のポイントを抑えておくこと．
- だいたい1分間以下で完了するテストにすること．CRAN で実行すべきでないテストは，冒頭に skip_on_cran() を記述する．
- テストは常に 英語環境（LANGUAGE=EN） で実行され，ソート順は C ソート（LC_COLLATE=C）になる．
- CRAN 環境のマシンで内容が変わるかもしれないテスト対象がないか，注意する．数値の精度もプラットフォームに依存するため，expect_identical() ではなく，expect_equal() を使う．
** 名前空間
NAMESPACE ファイルは，自分のパッケージにおいて，
- どの関数が他のパッケージから使うことができるか
- どの関数が他のパッケージに依存しているか
を定義する．
roxygen2 を使って生成する．

苦労の割にメリットが少なく感じるかもしれないが，そんなことはない．
よく設計すれば，パッケージをうまくカプセル化し，自己完結性を向上させられる．
*** 動機付け
summarize()は，plyrにも，Hmiscにもある．
こんなとき，::をつかったことあるだろ．
関数名は，パッケージのロード順に上書きされる．
::を使えば，依存がなくなる．
**** パッケージの自己完結性を高めるために
インポートとエクスポートを使う．
***** インポート
nrow関数の中身
: function (x)
: dim(x)[1L]
: <bytecode: 0x7f8576310720>
: <environment: namespace:base>

nrow() は dim() を使って書かれていることがわかる．
では，dim()を書き換えてしまうと，nrow()は動かなくなってしまうのか？

そんなことはない．
base の名前空間のdim()を使っているから．
***** エクスポート
外部に公開する関数だけ，エクスポートする．
衝突の可能性を減らすため，必要最小限の関数だけエクスポートしたくなるはず．

*** 検索パス
アタッチしている全てのパッケージのリスト．
#+BEGIN_SRC R
search()
#+END_SRC

#+RESULTS:
| .GlobalEnv        |
| package:stats     |
| package:graphics  |
| package:grDevices |
| package:utils     |
| package:datasets  |
| package:formatR   |
| package:beepr     |
| MacJapanEnv       |
| package:methods   |
| Autoloads         |
| package:base      |

**** ロードとアタッチは別物
library()とrequire()がやっているのはアタッチ．

インストール済みのパッケージをロードすると（どうやって？），
- コード，データ，DLLがロードされる
- S3 と S4 のメソッドが登録される
- onLoad() 関数が実行される


***** アタッチしないときはエラー
#+BEGIN_SRC R
old <- search()
testthat::expect_equal(1, 1)
setdiff(search(), old)
expect_true(TRUE)
#+END_SRC

#+RESULTS:

***** アタッチすれば通る
#+BEGIN_SRC R
library(testthat)
old <- search()
testthat::expect_equal(1, 1)
setdiff(search(), old)
expect_true(TRUE)
#+END_SRC

#+RESULTS:
: TRUE

***** ロード，アタッチ関数の挙動の違い
| 実行内容                              | 動作     | パッケージがないとき | 使い所               |
|---------------------------------------+----------+----------------------+----------------------|
| loadNamespace("x")                    | ロード   | エラー発生           | ない                 |
| requireNamespace("x", quietly = TRUE) | ロード   | FALSEを返す          | *パッケージ内部*     |
| library(x)                            | アタッチ | エラー発生           | データ分析スクリプト |
| require(x, quietly = TRUE)            | アタッチ | FALSEを返す          | ない                 |

パッケージ内部では，アタッチは絶対にしてはいけない！
つまり，require() と library() は絶対だめ．
DESCRIPTION の Depends や Imports を使おう．

***** Depends と Imports はどう違うか
- Imports: ロードだけ
- Depends: ロードとアタッチをする
基本的に，Imports にしとけ．
他のパッケージと組み合わせて使うことを前提に設計する場合のみ，Depends にする．
*** 名前空間
NAMESPACE ファイルの中身，Rコードみたい．
それぞれの行に，
- S3method()
- export()
- exportClass()
などの<<<ディレクティブ>>>が含まれている．

ディレクティブは全部で10種類ある．
でも，手作業でいちいち指定しなくて大丈夫（なぜなら，[[*NAMESPACE %E3%81%AF roxygen2%E3%81%A7%E4%BD%9C%E3%82%8C][NAMESPACE は roxygen2で作れ]]）
一応説明する．
**** エクスポート
- export(): 関数をエクスポートする
- exportPattern(): パターンにマッチする全ての関数をエクスポートする
- exportClasses() と exportMethods(): S4のクラスとメソッドをエクスポートする
- S3method(): S3メソッドをエクスポートする
**** インポート
- import(): 対象のパッケージから全ての関数をインポートする
- importFrom(): 指定された関数をインポートする
- importClassesFrom() と importMethodsFrom(): S4クラスとメソッドをインポートする
- useDynLib(): Cライブラリから関数をインポートする（第10章 [[*%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E6%B8%88%E3%81%BF%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89][コンパイル済みのコード]] で説明）
**** NAMESPACE は roxygen2で作れ
メリット
- 名前空間の定義が関連する機能のすぐ近くに記述されるので，インポート・エクスポート対象がわかりやすい
- @export とするだけで，自動的に適切なディレクティブで記述される
- NAMESPACEファイルを整理された状態に保てる．同じインポートタグを何度も使っても，NAMESPACEの中に重複が生じることはない
*** ワークフロー
関数ドキュメントの作成と同じ流れ．
- .R ファイルに roxygen コメントを追加する
- devtools::document() を実行
- NAMESPACE ファイルを確認し，テストを実行して，正しい仕様になっているか確認する
- 正しい機能がエクスポートされるまで繰り返す
*** エクスポート
開発したパッケージの関数を外からも使えるようにするには，関数をエクスポートする必要がある．
新しいパッケージを devtools::create() で作ると，全ての項目をエクスポートしている一時的なNAMESPACE ファイルが生成する．
ただし，これはあくまでも開発用．
このまま他人に配ると，他のパッケージと衝突する可能性がある．

オブジェクトをエクスポートするには，@export をroxygen ブロックに挿入するだけでいい．

#+BEGIN_SRC R
#' @export
foo <- function(x, y, z) {
  ...
}
#+END_SRC
なんてかんたん！！！
***** 注意点
- インターフェースを変更するときは注意が必要．ユーザーのコードがいきなり動かなくなったりする．
- エクスポートする対象は極力少なく．増やすのは簡単だが，減らすのは問題になりやすい．使っていた関数がいきなりなくなったら，ユーザは困る．
常にシンプルに保て．

***** いろんな機能を持ったMISCパッケージはだめ
自分で使うならまだ良いけど．
1つのパッケージは，1つの問題に特化せよ．
（UNIX哲学に通じるところがある．だからtidyverseがあるのか．）

**** S3
パッケージの外で，S3クラスのインスタンスを作成できるようにしたいときは，@export でコンストラクタ関数をエクスポートする（glmなどはこれをやっている？）．
@export でエクスポートできる．

ただし，S3メソッドのエクスポートはかなり複雑．
それは，以下の4シナリオが考えられるため．

- エクスポートしているジェネリックを実装したメソッド: 全てのメソッドをエクスポートする必要がある
- 内部で利用しているジェネリックを実装したメソッド: 必要はないのだが，バグ発生リスクを回避するためには，全てのメソッドをエクスポートした方が良い．エクスポートのし忘れは，devtools::missing_s3()で調べられる
- 依存しているパッケージのジェネリックを実装したメソッド: ジェネリックを [[*%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88][インポート]] し，このメソッドをエクスポートする必要がある
- Suggestsに含まれるパッケージのジェネリックを実装したメソッド: この状態が生じないように設計するべき．名前空間ディレクティブは，Suggests に含まれるパッケージを参照することができない

**** S4
S3と同様，@export でエクスポートできる．
「インスタンスの生成は許可するが，クラスの継承はさせたくない」，という時には，以下の例のようにする．
例では，クラスではなく，コンストラクタ関数で@export を使っている．

#+BEGIN_SRC R
  # 継承とnew("A", ...)によるインスタンス生成，どっちもできる．
  #' @export
  setClass("A")
  # 継承とnew("B", ...)によるインスタンス生成，どっちもできる．
  # ただし自コード内ではB()によってインスタンスは作成できるが，外部からはできない．
  #' @export
  B <- setClass("B")

  # コンストラクタでのnew("C", ...)，およびC()によるインスタンス生成はできるが，継承はできない．
  #' @export C
  C <- setClass("C")

  # 継承と，new("D", ...)，D()によるインスタンス生成だけできる．
  #' @export D
  #' @exportClass D
  D <- setClass("D")
#+END_SRC

S4のジェネリックを公開するのも@export．
S4メソッドは，自分が定義していないジェネリックを実装したメソッドだけを@exportすれば足りるが，
ジェネリックを作ったかどうかを気にするだけ無駄なので，全部@exportするのがおすすめ

**** RC
S4のクラスと同じ原則．
RCでは，現在のところパッケージ外からクラスを継承することはできない．

**** データ
エクスポートする必要はない．詳しくは [[*%E5%A4%96%E9%83%A8%E3%83%87%E3%83%BC%E3%82%BF][外部データ]] で学ぶ．
*** インポート
NAMESPACEファイルは，自分のパッケージから::なしで呼びたい外部関数の制御も行う．
ただし，その前にDESCRIPTION の Imports フィールドが何よりも優先．[[*%E5%85%B7%E4%BD%93%E7%9A%84%E3%81%AB%EF%BC%8C%E3%81%A9%E3%81%86%E3%82%84%E3%81%A3%E3%81%A6%E3%82%A4%E3%83%B3%E3%83%9D%E3%83%BC%E3%83%88%E3%81%99%E3%82%8B%E3%81%AE%E3%81%8B][具体的に，どうやってインポートするのか]] を参照すること
***** 紛らわしいポイント
- DESCRIPTION の Imports: フィールド
- NAMESPACE の importディレクティブ
両方が”インポート”の概念をもっているところが紛らわしい．

***** 関数をインポートするときの注意点
自分のパッケージに，外部パッケージから関数をインポートするときには，
その外部パッケージがアタッチされているかどうかに関わらず，全く同じ手順を踏む必要がある．

なぜか？
DESCRIPTION の Imports フィールドは，自分が開発したパッケージをユーザが使うときに，
ここに指定したパッケージが「（単に）インストール」されていることを保証しているだけだから．
つまり，関数をすぐさま利用可能にしているわけではないから．
***** 具体的に，どうやってインポートするのか
- 外部パッケージを DESCRIPTION の Imports に記載し，インストールされていることを保証する
- 関数を使うときに，明示的に pkg::fun() と参照する
これに尽きる．

NAMESPACE にだけ，パッケージを記載しておわり，はだめ．
これをやっても何にもならない．
どうせここに書いた関数は，Imports や Depnds フィールドにも書かないといけない．
***** Depends フィールドに記載されたパッケージの挙動
- 自分が開発したパッケージがアタッチされたとき: 同時にアタッチされる
- 自分が開発したパッケージがロードされたとき: 同時にロードされる．アタッチはされない

**** R関数
上で述べたように，
- DESCRIPTION の Imports に記載
- pkg::fun() で呼び出す
- 何度も呼び出すのが面倒だなと思って初めて，@importFrom pkg fun する．
- その外部パッケージの多くの関数を何度も使用するときには，@import package を使って，それらの全てをインポートする（が，衝突の可能性が高まるので勧めない）

**** S3
S3のジェネリックは単なる関数なので，手順は他の関数と同じ．
特別なことはなにもない．ジェネリックにアクセスできれば，全てのメソッドが利用できる．
**** S4
難しい．
***** 別パッケージの「クラス」を使うには
- インポートしたクラスを継承するクラスの付近
- インポートしたクラスのジェネリックを実装するメソッドの付近
に，@importClassesFrom package ClassA ClassB ... のように定義する．
***** 別パッケージの「ジェネリック」を使うには
インポートしたジェネリックを使用するメソッドの付近に
@importMethodsFrom package GenericA GenericB ... のように定義する．
***** 見落としがちな methods パッケージ
S4 を実装してくれているのが，methods パッケージ．
このパッケージは対話的な R 環境では常に検索パスにあるため普段意識することはないが，
Rscript では自動的にロードされていないので注意が必要．

methods パッケージの関数を使う機会は多いので，パッケージ全体をインポートしたくなるかもしれない．
そんなときは，[[*%E3%83%91%E3%83%83%E3%82%B1%E3%83%BC%E3%82%B8%E3%81%AE%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88][パッケージのドキュメント]] で見たように，パッケージのドキュメントの中に
#+BEGIN_SRC R
#' @imports methds
NULL
#+END_SRC
と書くと良い．
ここのNULLは，この methods パッケージが，
特定の機能のためだけにインポートされているわけではないことを明確にしている．

**** コンパイル済みの関数
[[*%E3%82%B3%E3%83%B3%E3%83%91%E3%82%A4%E3%83%AB%E6%B8%88%E3%81%BF%E3%81%AE%E3%82%B3%E3%83%BC%E3%83%89][コンパイル済みのコード]] を参照のこと．
** 外部データ
data/を使えば，パッケージ内にデータを含められる．
- ユーザが簡単にデータにアクセスするため
- わかりやすい例を示すため


データで何をしたいか，誰がデータを使えるようにするかに応じ，3つの方法がある．
- バイナリ，ユーザ使用可（チュートリアル用途など）: data/ におく
- ユーザに使用させたくない場合（関数に必要なデータなど）: R/sysdata.rda
- 生データを保存したい場合: inst/extdata
*** エクスポートされたデータ: data/
あるオブジェクトを sava() すると，.RDataファイルが生成する．
devtools::use_data() でこれができる．

.RData ファイルのメリット
- 高速
- 容量が小さい
- わかりやすい

LazyData: true とすると，データはアタッチされるまでメモリを圧迫しない．
データを整形したときのコードは data-raw/ に置き，.Rbuildignore に加えておく．
devtolls::use_data_raw() で一括でできる．

**** データセットのドキュメント
これも roxygen2 で作る．
@export を使ってはいけない．

@format: 変数リストや変数の単位など
@source: \url{} など，データの由来の詳細を記述する

*** 内部データ R/sysdata.rda
data/ に置くとユーザから見えてしまうのでだめ．
devtools::use_data()の引数をinternal = TRUE とする．


*** 生データ inst/extdata
パッケージがインストールされると，トップレベルのディレクトリに移動される．

*** その他のデータ
- テストのためのデータ: test/ に置く
- vignette のためのデータ: data/ またはinst/extdata

*** CRAN に関する設定
データは1 MBより小さく保つこと．
- tools::checkRdaFiles(): 各ファイルに最適な圧縮方法を決める
- compress: に最適値を設定し，davtools::use_data() を再実行．
** コンパイル済みのコード
src/
高速なコンパイル済コードを入れる場所
パッケージのパフォーマンスのボトルネックになっている部分を解決する

** インストール済のファイル
inst/
任意の追加ファイルを入れる．
- 引用
- ライセンス
- 著作権
** その他のコンポーネント
- demo/
- exec/
- po/
- tools
* ベストプラクティス
特定のディレクトリに対してではなく，一般的なベストプラクティスについて
** Git と GitHub
RStudioで使う方法
** 自動チェック
自動品質チェック機能
自動チェックの結果が出す警告の読み方
R CMD check
** パッケージのリリース
2つのリリース方法
- CRAN
- GitHub
