#+TITLE: Docker
#+startup: overview
#+property: header-args :results output :session *shell:docker*
* 第I部 背景と基本
** 第1章 コンテナとはなにか
アプリケーションを依存対象とともにカプセル化したもの．
VMっぽいが，以下の点で違う．
- ホストOSとリソースを共有するので，効率的．
- 最上級のポータビリティ
- とても軽い
- 複雑なアプリをダウンロードして実行できる

*** コンテナとVM
VMとはちがう
どこが？
**** 各種特徴
- ホストOSとリソースを共有する
- 環境が完全に同じになる
- 軽いので，同時にたくさん実行できる
- エンドユーザーからすると，設定やインストールに時間をとられない
**** そもそものゴール
VMは環境のエミュレート，コンテナはポータビリティ
*** Dockerとコンテナ
コンテナの概念自体は古いが，Dockerがもたらした新技術によって普及した
- Swarm: クラスタマネージャ
- Kitematic: コンテナを扱うGUI
- Machine: ホストをプロビジョニングするためのコマンドラインutil
- Docker Hub: コンテナ配布のためのクラウドサービス
** 第2章 インストール
** 第3章 はじめの一歩
動作の感覚を掴む
Dockerfileの説明
Dockerレジストリの説明
*** 初めてのイメージ実行
ダウンロードも自動でされる．
*** 基本のコマンド群
- docker run -h -i -t
- docker inspect: 詳細な情報
- docker diff: 変更履歴
- docker logs:
- docker rm:
- docker commit: イメージ化．でも，手作業はめんどい．
fortuneの格言を，cowsayに喋らせて遊ぶ．
*** Dockerfile からのイメージ構築
- docker build: これでイメージができる
- docker run: cowsayコマンドいらなくなる．でも，fortuneとの連携がなくなってしまった．
- entrypoint.sh: 引数があるときはそれをcowsayにわたす．ないときは，fortuneの出力をcowsayにわたす．
イメージとコンテナの違い: 複数のレイヤがイメージを作っており，docker runやdocker createによってイメージがコンテナに変換される．
*** レジストリでの作業
Docker Hubにアップロードできる
*** Redisの公式イメージの利用
よくわからんが，データを追加し，それをバックアップして永続化できるらしい．
** 第4章 Dockerの基礎
Dockerの技術の基盤となっている技術も見ていく．
ポイントだけ見ておき，第5章を読んだあとに戻ってきてもいいとのこと．
*** Dockerのアーキテクチャ
- デーモン
- クライアント
- イメージ:
- レジストリ: イメージの保存と配布．ふつうDocker Hubがやる．
**** 基盤の技術
Dockerデーモンは，実行ドライバを使ってコンテナを作成する．
これはDocker独自のruncドライバで，以下のカーネルの機能と密接につながっている．
- cgroups
- namespaces: コンテナの隔離
- Union File System
**** 周辺の技術
以下の支援技術から成り立っている．
- Swarm: 複数のDockerホストをまとめる
- Compose: アプリ構築と実行
- Machine: Dockerホストをインストール，設定
- Kitematic: コンテナ実行と管理のためのGUI．MacOSとWindowsのためのもの．
- Docker Trusted Registry:
- ネットワーキング
- サービスディスカバリ
- オーケストレーションおよびクラスタ管理
**** Dockerのホスティング
クラウドプロバイダの多くが，Dockerを提供している．
*** イメージの構築
**** ビルドコンテキスト
DockerfileのADDやCOPYから参照できる，ローカルファイルやディレクトリの集合．
**** イメージのレイヤ
Dockerfileの命令の数だけレイヤが作られる？
**** キャッシュ
高速化が目的
**** ベースイメージ
公式のイメージを使うと，いい結果が得られることか多い．
先人たちの努力の恩恵に預かることができる
**** Dockerfileの命令
- ADD
- CMD
- COPY
- ENTRYPOINT
- ENV
- EXPOSE
- FROM
- MAINTAINER
- ONBUILD
- RUN
- USR
- VOLUME
- WORKDIR
*** 外界とのコンテナの接続
コンテナ内でWebサーバを動作させ，外部からアクセスできる．
*** コンテナのリンク
コンテナ同士で通信させる．
*** ボリュームとデータコンテナを使ったデータの管理
ボリュームの宣言方法
- 実行時に -vオプションで
- Dockerfile内でVOLUME命令で（おすすめ？）
- -v HOST_DIR:CONTAINER_DIRとする（ポータブルでなくなるのてよくない）
**** データの共有
--volumes-from CONTAINERとして，データを共有できる
**** データコンテナ
他のコンテナとデータを共有することだけを目的としたコンテナを作ってもいい．
*** Dockerの一般的なコマンド
日々進化しているので，公式HPを見ること．
**** run
***** -a, --attach
コンテナのstdoutなどをターミナルにアタッチ
***** -d, --detach
コンテナはバックグラウンドで動く
***** -i, --interactive
stdinをオープンにしたままで
***** --restart
終了したコンテナをDockerが再起動しようとするタイミングを指定
***** --rm
終了時にコンテナを自動的に削除
***** -t, --tty
キーボードからの制御
***** -e, --env
コンテナ内の環境変数を設定
***** -h, --hostname
コンテナのUnixホスト名を設定
***** -name NAME
NAMEという名前空間をコンテナに割り当てる
***** -v --volume
ボリュームを宣言する
***** --volumes-from
指定されたコンテナからボリュームをマウントする
***** --expose
コンテナで使われるポートやその範囲を指定する．-pコマンドとともに使う
***** --link
プライベートなネットワークをつくる
***** -p, --publish
コンテナのポートを公開
***** -p, --publish-all
コンテナの開放されたポートをすべて公開
***** --entrypoint
コンテナのエントリポイントを指定された引数に設定する．
***** -u, user
コマンドを実行するユーザを指定する
***** -w, --workdir
作業ディレクトリを指定
**** コンテナの管理
***** docker attach [OPT] CONTAINER
***** docker create
***** docker cp
***** docker exec
***** docker kill
***** docker pause
***** docker restart
***** docker rm
***** docker start
***** docker stop
***** docker unpause
**** Dockerの情報
***** docker info
***** docker help
***** docker version
**** コンテナの情報
***** docker diff
***** docker events
***** docker inspect
***** docker logs
***** docker port
***** docker ps
***** docker top
**** イメージの扱い
***** docker build
***** docker commit
***** docker export
***** docker history
***** docker images
***** docker import
***** docker load
***** docker rmi
remove image
***** docker save
***** docker tag
デフォルトは，latest
**** レジストリの利用
Docker Hubを利用するためのコマンド
***** docker login
***** docker logout
***** docker pull
***** docker push
***** docker search
*** まとめ
ここまでの内容は，第II部の実践の様子を見てからの方が，わかりやすいだろう．
* 第II部 Dockerのあるソフトウェアライフサイクル
第I部では，コンテナの背後にある考え方を紹介し，その基本的な使い方に触れた．
第II部では，Dockerを使ってWebアプリ構築，テスト，デプロイをやってみる．
コンテナは，数ヶ月単位
** 第5章 開発でのDockerの利用
テキストに対して画像を表示するアプリを開発する（GitHubのアカウントイメージなど）．
Python と Flask を使うが，依存性の管理は全てDockerでやるので，インストール作業は必要ない．
ただし，本章では前段階として
- コンテナベースのワークフローの利用方法
- ツールの準備
について学ぶ．
*** "Hello, World!"
テキストに従い，identidock.py と Dockerfile を作成した．
p.72のflaskのインポートのインデントが間違っていた．
#+BEGIN_SRC sh
  tree
#+END_SRC

#+RESULTS:
#+begin_example
.
|-- docker.org
|-- docker.org~
`-- identidock
    |-- Dockerfile
    `-- app
        |-- identidock.py
        `-- identidock.py~

2 directories, 5 files
#+end_example
**** ビルド build -t
#+BEGIN_SRC sh
cd identidock
docker build -t identidock .
#+END_SRC

#+RESULTS:
#+begin_example
Sending build context to Docker daemon   5.12kB
Step 1/5 : FROM python:3.4
3.4: Pulling from library/python
cd8eada9c7bb: Pulling fs layer
c2677faec825: Pulling fs layer
fcce419a96b1: Pulling fs layer
045b51e26e75: Pulling fs layer
83aa5374cd04: Pulling fs layer
4700226d49ed: Pulling fs layer
be308e58b7c7: Pulling fs layer
c3da57aa10c1: Pulling fs layer
2290aab05593: Pulling fs layer
4700226d49ed: Waiting
be308e58b7c7: Waiting
c3da57aa10c1: Waiting
045b51e26e75: Waiting
83aa5374cd04: Waiting
2290aab05593: Waiting
fcce419a96b1: Verifying Checksum
fcce419a96b1: Download complete
c2677faec825: Verifying Checksum
c2677faec825: Download complete
cd8eada9c7bb: Download complete
cd8eada9c7bb: Pull complete
c2677faec825: Pull complete
fcce419a96b1: Pull complete
045b51e26e75: Verifying Checksum
045b51e26e75: Download complete
4700226d49ed: Verifying Checksum
4700226d49ed: Download complete
c3da57aa10c1: Verifying Checksum
c3da57aa10c1: Download complete
045b51e26e75: Pull complete
2290aab05593: Verifying Checksum
2290aab05593: Download complete
be308e58b7c7: Verifying Checksum
be308e58b7c7: Download complete
83aa5374cd04: Verifying Checksum
83aa5374cd04: Download complete
83aa5374cd04: Pull complete
4700226d49ed: Pull complete
be308e58b7c7: Pull complete
c3da57aa10c1: Pull complete
2290aab05593: Pull complete
Digest: sha256:5a813f0305e2edb26052f9490f321f7c515bf6f5a9461164891443695b85b293
Status: Downloaded newer image for python:3.4
 ---> ccbffa0d70d9
Step 2/5 : RUN pip install Flask==0.10.1
 ---> Running in 6b67b768eafb
Collecting Flask==0.10.1
  Downloading https://files.pythonhosted.org/packages/db/9c/149ba60c47d107f85fe52564133348458f093dd5e6b57a5b60ab9ac517bb/Flask-0.10.1.tar.gz (544kB)
Collecting Werkzeug>=0.7 (from Flask==0.10.1)
  Downloading https://files.pythonhosted.org/packages/20/c4/12e3e56473e52375aa29c4764e70d1b8f3efa6682bef8d0aae04fe335243/Werkzeug-0.14.1-py2.py3-none-any.whl (322kB)
Collecting Jinja2>=2.4 (from Flask==0.10.1)
  Downloading https://files.pythonhosted.org/packages/7f/ff/ae64bacdfc95f27a016a7bed8e8686763ba4d277a78ca76f32659220a731/Jinja2-2.10-py2.py3-none-any.whl (126kB)
Collecting itsdangerous>=0.21 (from Flask==0.10.1)
  Downloading https://files.pythonhosted.org/packages/76/ae/44b03b253d6fade317f32c24d100b3b35c2239807046a4c953c7b89fa49e/itsdangerous-1.1.0-py2.py3-none-any.whl
Collecting MarkupSafe>=0.23 (from Jinja2>=2.4->Flask==0.10.1)
  Downloading https://files.pythonhosted.org/packages/3e/a6/230a77104000937d717c300bcefe907a960d437e1a721e49c5fb40deb1c0/MarkupSafe-1.1.0-cp34-cp34m-manylinux1_x86_64.whl
Building wheels for collected packages: Flask
  Running setup.py bdist_wheel for Flask: started
  Running setup.py bdist_wheel for Flask: finished with status 'done'
  Stored in directory: /root/.cache/pip/wheels/e1/f2/be/1c4f307a41aad7e632f79c0242a2714ecde24b663da3519665
Successfully built Flask
Installing collected packages: Werkzeug, MarkupSafe, Jinja2, itsdangerous, Flask
Successfully installed Flask-0.10.1 Jinja2-2.10 MarkupSafe-1.1.0 Werkzeug-0.14.1 itsdangerous-1.1.0
Removing intermediate container 6b67b768eafb
 ---> a8f11f056505
Step 3/5 : WORKDIR /app
 ---> Running in d6af8969da3b
Removing intermediate container d6af8969da3b
 ---> a51044a97e90
Step 4/5 : COPY app /app
 ---> b0302a02d215
Step 5/5 : CMD ["python", "identidock.py"]
 ---> Running in 230ca00cc63d
Removing intermediate container 230ca00cc63d
 ---> f6aa9810340a
Successfully built f6aa9810340a
Successfully tagged identidock:latest
#+end_example
**** コンテナ起動 run -d -p
-d はコンテナをバックグラウンドで起動．出力を見たければこれはつけなくていい．これのせいでエラーが見えなくてハマった．
-p 5000:5000 はコンテナの5000番ポートをホストの5000番ポートにフォワードするよう支持している．

#+BEGIN_SRC sh
docker run -d -p 5000:5000 identidock
#+END_SRC

#+RESULTS:
: 0d22b919c274c6c60763e8004ed6bc3765d5ea8efdf4f64ad949e16cb97079b8
**** 実行 curl
identidock.py のインデントが間違っていたせいでうまくできなかったが，修正して，再度dokcer runしたらできた．
#+BEGIN_SRC sh
curl localhost:5000
#+END_SRC

#+RESULTS:
: Hello World!

**** ここまでワークフローの問題点とその解決法
コードを少し変更するたびに，イメージを再構築してコンテナを再起動しないといけない．めんどくさい．
どうするか？
コンテナのソースコードのフォルダの上に，ホストのソースコードのフォルダを<<<バインドマウント>>>してしまえばいい．
#+BEGIN_SRC sh
docker stop $(docker ps -lq)
docker rm $(docker ps -lq)
docker run -d -p 5000:5000 -v "$(pwd)"/app:/app identidock
#+END_SRC

#+RESULTS:
: 8a01eddc2af5
: 8a01eddc2af5
: e361948cc614b37ed9681138d8a5e074c53f6f5925de8d5adb35e19cf03c999c
***** 解説
$(pwd)/app:/app によって，コンテナ内で書き込みもできるようになる．
-v への引数は絶対パスでないといけないので，$(pwd)で補完している．ということは前半がホストのフォルダ．作業手順もポータブルになってなおいい．
**** バインドマウントした状態での動作確認
#+BEGIN_SRC sh
curl localhost:5000
#+END_SRC

#+RESULTS:
: Hello World!
できた！！
**** .pyファイルを編集し，バインドマウントの効果を確認
#+BEGIN_SRC sh
sed -i '' s/World/Docker/ app/identidock.py
curl localhost:5000
#+END_SRC

#+RESULTS:
:
: Hello Docker!
***** これが何を意味するか？
ごく普通の開発環境がDockerコンテナの中にカプセル化できたことをいみする．
**** 現状の問題
実働環境では使えない．
なぜか？
*開発目的* のデフォルトのFlask Webサーバで動作しているので，
- 効率が悪い
- セキュアでない
お客さんには提供できない．
これから，開発環境と実働環境の差を減らしていく．
** 第6章 シンプルなWebアプリケーションの作成
いよいよ開発する．
さっきのHello world!プログラムを，テキストに応じて画像を表示するwebアプリにする．
画像はユーザー名やIPに基づき，自動生成させる．
本章で作るアプリは，続く章でも使う．
完全に動作するコンテナの作りかたを学ぶ．


** 第7章 イメージの配布
誰に配布するか？
- 同僚
- CIサーバ
- エンドユーザ
配布方法も複数ある．
ケースに合った方法を選択するためのガイド．

** 第8章 Dockerを使った継続的インテグレーションとテスト
Jenkinsを使ったCI
ポータビリティとコンテナのサイズのトレードオフ
** 第9章 コンテナのデプロイ
本当の実働環境，サービスにおいてDockerを使うことは十分に可能．
VM上でコンテナを起動する方法がよくとられているが，これは本当はベストではない．
これまで作ったアプリを，様々なクラウドやサービスにデプロイできることを見ていく．
** 第10章 ロギングとモニタリング
集中型のログのとり方
短命なコンテナを多数使うマイクロサービスアーキテクチャでは重要な手法．
* 第III部 ツールとテクニック
** 第11章 ネットワーキングとサービスディスカバリ
ネットワーキングとサービスディスカバリの境界はなくなりつつある（らしい）．
難しい．さっと読んだ感じ，理解できない．
** 第12章 オーケストレーション，クラスタリング，管理
ユーザーの要求に応じて，リソースを素早くスケールアップ・ダウンできないといけない．
そのためには，全てのマシンをペットのように丁重に扱うのではなく，家畜のように集団として扱うべき．
障害が生じたら直すのではなく，廃棄して置き換える．

** 第13章 セキュリティとコンテナに対する制限
コンテナを利用する時に検討しておくべき，セキュリティ事項について見てみる．
